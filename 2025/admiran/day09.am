|| day09.am -- Movie Theater


%export day09

%import "adventLib"
%import <lens>
%import <maybe>
%import <v2>
%import <vector>


|| sort two ints from lo to hi
minMax :: int -> int -> (int, int)
minMax a b
    = case cmpint a b of
        GT -> (b, a)
        _  -> (a, b)

pos  == v2 int

rect ::= Rect int int int int

r_t (Rect t b l r) = t  || top
r_b (Rect t b l r) = b  || bottom
r_l (Rect t b l r) = l  || left
r_r (Rect t b l r) = r  || right

|| make a rectangle from two opposite corners
makeRect :: pos -> pos -> rect
makeRect (V2 r1 c1) (V2 r2 c2)
    = case minMax r1 r2 of (t, b) ->
      case minMax c1 c2 of (l, r) ->
      Rect t b l r

area :: rect -> int
area (Rect t b l r) = (b - t + 1) * (r - l + 1)

segT ::= Horiz | Vert
seg  == (segT, int, int, int)

s_t (t, a, l, h) = t    || seg type
s_a (t, a, l, h) = a    || seg anchor (row, if seg is Horiz, col, if seg is Vert)
s_l (t, a, l, h) = l    || seg range lo
s_h (t, a, l, h) = h    || seg range hi

isHoriz (Horiz, _, _, _) = True
isHoriz _                = False

makeSeg :: pos -> pos -> seg
makeSeg (V2 r1 c1) (V2 r2 c2)
    = mkSeg Horiz r1 (minMax c1 c2), if r1 == r2
    = mkSeg Vert  c1 (minMax r1 r2), otherwise
      where
        mkSeg t a (l, h) = (t, a, l, h)

edges :: rect -> [seg]
edges (Rect t b l r) = [(Horiz, t, l, r), (Vert, r, t, b), (Horiz, b, l, r), (Vert, l, t, b)]

|| read the path, then break into horiz/vert segs, sort each and group on common anchor value, and create vectors
|| return the corners and the horiz/vert group vectors
parseSegs :: string -> ([pos], vector [seg], vector [seg])
parseSegs
    = lines .> map (split ',' .> map intval .> mkV2) .> mkSegs
      where
        mkV2 [c, r] = V2 r c    || example diagram shows input values as c, r, but we canonicalize to r, c
        mkV2 _      = error "parse error"

        mkSegs xs = mkPath xs |> mkParts |> \(hs, vs) -> (xs, hs, vs)
        mkPath xs = zipWith makeSeg xs (tl xs ++ [hd xs])
        mkParts   = sortBy cmpseg .> span isHoriz .> mapBoth (groupBy ((==) $on s_a) .> v_fromList)

|| count the number of crossings of segs starting at index i until we reach or exceed a seg with anchor value lim
countCrossings :: vector [seg] -> int -> int -> int -> int
countCrossings vs x i lim
    = trace ("countCrossings " ++ showint x ++ " " ++ showint i ++ " " ++ showint lim) $ go 0 i
      where
        len = v_length vs

        go cross i = undef, if trace (showint cross ++ " " ++ showint i) False
        go cross i
            = trace ("done") cross,                         if i >= len \/ anchor > lim
            = cross' $seq go cross' (i + 1), otherwise
              where
                segs   = vs !! i
                anchor = hd segs |> s_a
                cross' = cross + 1, if any covers segs
                       = cross,     otherwise

        covers s = s_l s <= x <= s_h s

|| a valid rect has all corners inside polygon and edges that don't cross other polygon edges
|| where "inside" is determined by counting the number of segs crossed by traversing up / left
|| (odd = in, even = out). If nearest seg anchor == start scan, then it is in.
validRect :: vector [seg] -> vector [seg] -> rect -> bool
validRect hs vs r
    = trace ("validRect " ++ showrect r) $ all checkSeg $ edges r
      where
        checkSeg s
            = process vs s, if isHoriz s
            = process hs s, otherwise
              where
                process vx (_, a, l, r) = odd (countCrossings vx a 0 l) & countCrossings vx a l r == 0

|| 1527936636 is too low
day09 :: io ()
day09
||    = readInput "day09" >>= parseSegs .> go
    = readFile "day09.txt" >>= parseSegs .> go
      where
        go (corners, hsegs, vsegs)
            = output [part1, part2]
              where
                rects   = [makeRect a b | a : bs <- tails corners; b <- bs]                
                valid   = filter (validRect hsegs vsegs) rects
                process = map area .> max cmpint .> showint
                part1   = process rects
                part2   = trace (showlist showrect valid) $ process valid
