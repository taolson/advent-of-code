|| day08.am -- Playground


%export day08

%import "adventLib"
%import <map>
%import <maybe>
%import <v3>


box     == v3 int
boxPair == (box, box)

square :: int -> int
square x = x * x

dist :: boxPair -> int
dist (a, b) = v3_sub a b |> v3_fmap square |> v3_sum

|| since we will be taking only the first part of the sorted distances,
|| use a lazy qsort to sort the boxPairs so that not all pairs have to be
|| sorted first.
qsort :: [boxPair] -> [boxPair]
qsort [] = []
qsort (x : xs)
    = qsort lo ++ [x] ++ qsort hi
      where
        d  = dist x
        lo = filter (\p -> dist p < d) xs
        hi = filter (\p -> dist p > d) xs

closestPairs :: [box] -> [boxPair]
closestPairs vs
    = allPairs |> qsort
      where
        allPairs = [(a, b) | a : r <- tails vs; b <- r]

cmap == m_map int [box]         || map from a cluster id to its boxes
rmap == m_map box int           || map from a box to its cluster id
cst  == (cmap, rmap, boxPair)   || state passed through cluster

getCmap :: cst -> cmap
getCmap (cm, _, _) = cm

|| peform a clustering step on the current clusters and a boxPair
cluster :: cst -> boxPair -> cst
cluster (cm, rm, p) (a, b)
    = (classify $on (\x -> m_lookup cmpbox x rm)) a b
      where
        classify Nothing   Nothing   = newCircuit [a, b]        || neither box was already in a circuit
        classify (Just c)  Nothing   = addCircuit c b           || add box b to circuit of box a
        classify Nothing   (Just c)  = addCircuit c a           || add box a to circuit of box b
        classify (Just c1) (Just c2) = mergeCircuits c1 c2      || both boxes are in different circuits; merge them

        newCircuit bs
            = (cm', rm', (a, b))
              where
                new    = if' (m_null cm) 0 (m_last cm |> fst |> (+ 1))
                cm'    = m_insert cmpint new bs cm
                rm'    = foldl (\m b -> m_insert cmpbox b new m) rm bs

        addCircuit c x
            = (cm', rm', (a, b))
              where
                cm'    = m_insertWith cmpint (++) c [x] cm
                rm'    = m_insert cmpbox x c rm

        mergeCircuits c1 c2
            = (cm, rm, p),        if c1 == c2
            = (cm', rm', (a, b)), otherwise
              where
                bs  = m_findWithDefault cmpint [] c2 cm
                cm' = m_insertWith cmpint (++) c1 bs cm |> m_delete cmpint c2
                rm' = foldl (\m b -> m_insert cmpbox b c1 m) rm bs

parseBoxes :: string -> [box]
parseBoxes
    = lines .> map (split ',' .> map intval .> mkV3)
      where
        mkV3 [x, y, z] = V3 x y z
        mkV3 _         = error "parse error"

day08 :: io ()
day08
    = readInput "day08" >>= parseBoxes .> closestPairs .> go
      where
        go pairs
            = output [part1, part2]
              where
                (p1, p2) = splitAt 1000 pairs

                (cm, rm, _) = foldl cluster (m_empty, m_empty, hd p1) p1
                (_,  _,  p) = scanl cluster (cm, rm, hd p2) p2 |> dropWhile (getCmap .> m_size .> (> 1)) |> hd

                part1    = m_elems cm |> map length |> sortBy (descending cmpint id) |> take 3 |> product |> showint
                part2    = p |> mapBoth viewV3_0 |> uncurry (*) |> showint
