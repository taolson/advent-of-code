|| day02.am -- Gift Shop
||
|| The first version of this was a brute-force solution, trying the full range by chunking into pieces and comparing for equality
|| This version inverts that; it creates the possible patterns from the prodIds, then checks that the pattern is in range
|| runtime goes from 3.5s to 0.006s


%export day02

%import "adventLib"
%import <maybe>


prodId    == string
prodRange == (prodId, prodId)

|| divisibility tests used to generate possible pattern lengths
divisors, evenSplit :: int -> [(int, int)]
divisors  n = [(d, n $quot d) | d <- [1 .. n $quot 2]; n $rem d == 0]
evenSplit n = if' (even n) [(n $quot 2, 2)] []

|| given a lo, hi pid with equal number of digits, find all invalid ids between them
|| with pattern repetition lengths given by getDivisors
invalidInEqualRange :: (int -> [(int, int)]) -> prodId -> prodId -> [int]
invalidInEqualRange getDivisors lo hi
    = getDivisors len |> concatMap checkPatterns |> nub cmpint
      where
        nLo = intval lo
        nHi = intval hi
        len = #lo

        || check patterns of d digits replicated reps times
        checkPatterns (d, reps)
            = map (checkId reps) pats |> catMaybes
              where
                || create a range of d-digit numbers from the first d digits of lo and hi
                pats = mapBoth (take d .> intval) (lo, hi) |> uncurry range

        || create an id by repeating pat reps times, and see if it is in range
        checkId reps pat
            = Just n,  if nLo <= n <= nHi
            = Nothing, otherwise
              where
                n = showint pat |> rep reps |> concat |> intval

|| split range into two parts, if hi has more digits than lo
invalidInRange :: (int -> [(int, int)]) -> prodRange -> [int]
invalidInRange getDivisors (lo, hi)
    = invalidInEqualRange getDivisors lo hi,      if nlo == nhi
    = invalidInEqualRange getDivisors lo nines ++
      invalidInEqualRange getDivisors tens hi,    otherwise
      where
        nlo   = #lo
        nhi   = #hi
        nines = rep nlo '9'
        tens  = '1' : rep nlo '0'

parseRanges :: string -> [prodRange]
parseRanges
    = split ',' .> map (split '-' .> map (filter digit) .> mkRange)
      where
        mkRange [lo, hi] = (lo, hi)
        mkRange _        = error "parse error"

day02 :: io ()
day02
    = readInput "day02" >>= parseRanges .> go
      where
        go ranges
            = output [part1, part2]
              where
                part1 = process evenSplit
                part2 = process divisors

                process f = concatMap (invalidInRange f) ranges |> sum |> showint
