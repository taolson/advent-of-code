|| day14.m -- implementation using max-sized mutable vector for recipe state


%export day14

%import <io> (>>=.)/io_bind (<$>.)/io_fmap
%import <base>
%import <vector>
%import <state> (>>=)/st_bind (<$>)/st_fmap (>>)/st_right


sequence == (mvector int, int)  || sequence of digits, sequence length
elf      == int

s_init :: int -> [int] -> st sequence
s_init sz ds
    = enumerate ds |> st_mapM_ (\(i, x) -> v_unsafeWrite mv i x) >> st_pure (mv, #ds)
      where
        mv  = v_rep sz (-1) |> v_unsafeThaw

s_elfIndex :: sequence -> elf -> st int
s_elfIndex (s, _) e = v_read s (e - 1)

s_addDigit :: int -> sequence -> st sequence
s_addDigit n (s, i) = v_write s i n >> st_pure (s, i + 1)

s_addNZDigit :: int -> sequence -> st sequence
s_addNZDigit 0 = st_pure
s_addNZDigit n = s_addDigit n


recipeSt == (sequence, int, int)   || sequence, index of elf1, index of elf2

recipeStep :: recipeSt -> st recipeSt
recipeStep (s, e1, e2)
    = st_bind2 (s_elfIndex s e1) (s_elfIndex s e2) mix
      where
        mix r1 r2
            = s_addNZDigit (rs $div 10) s >>=
              s_addDigit   (rs $mod 10)   >>=
              updateElves
              where
                rs        = r1 + r2

                updateElves s'
                    = st_pure (s', e1', e2')
                      where
                        nDigits = snd s'
                        e1'     = (e1 + r1) $mod nDigits + 1
                        e2'     = (e2 + r2) $mod nDigits + 1

stepToSize :: int -> recipeSt -> st recipeSt
stepToSize sz rst
    = go rst
      where
        go rst
            = st_pure rst,           if rstSize rst >= sz
            = recipeStep rst >>= go, otherwise
              where
                rstSize ((_, n), _, _) = n

findDigits :: [int] -> recipeSt -> st int
findDigits pat rst
    = go rst
      where
        nDigits = #pat

        go rst
            = recipeStep rst >>= go, if sz < nDigits
            = extractLast >>= check, otherwise
              where
                ((mv, sz), _, _) = rst

                extractLast = st_mapM (v_unsafeRead mv) [sz - nDigits - 1 .. sz - 1]       || extract nDigits + 1 digits

                check ds
                    = st_pure (sz - nDigits - 1), if and $ zipWith (==) ds      pat
                    = st_pure (sz - nDigits),     if and $ zipWith (==) (tl ds) pat
                    = recipeStep rst >>= go,      otherwise

mkDigits :: int -> [int]
mkDigits 0 = [0]
mkDigits n
    = go [] n
      where
        go ds 0 = ds
        go ds n = go ((n $mod 10) : ds) (n $div 10)

|| initial version had an out-of-order sequencing bug which was uncovered when a change was made to compiler inlining;
|| this version forces correct sequential execution by sequencing each major part through the io monad, with each
|| minor part being independently sequenced via st_evalState
day14 :: io ()
day14
    = doInit >>= doSteps >>= doPart1 >>= doPart2
      where
        input = 880751

        doInit = st_evalState (s_init 22_000_000 [3, 7]) () |> \mv -> io_pure (mv, 1, 2)

        doSteps rst = st_evalState (stepToSize (input + 10) rst) () |> io_pure

        doPart1 rst
            = st_evalState (st_mapM (v_unsafeRead mv) [ndrop .. ndrop + nds - 1]) () |>
              concatMap showint |> ("part 1: " ++) |> putStrLn     >>
              io_pure rst
              where
                nds   = 10
                ndrop = input
                ((mv, _), _, _) = rst

        doPart2 rst
            = st_evalState (findDigits (mkDigits input) rst) () |> showint |> ("part 2: " ++) |> putStrLn
